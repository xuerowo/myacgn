<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="透過回答生活方式和性格問題，找出最適合你的遊戲職業！探索你的靈魂屬性，解鎖命定角色。">
    <meta name="keywords" content="遊戲職業,性格測試,RPG角色,職業配對,心理測驗,命定職業">
    <meta name="author" content="遊戲職業鑑定師">
    <meta name="theme-color" content="#24243e">
    <title>靈魂共鳴：命定遊戲職業鑑定</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            --primary: #b06ab3;
            --secondary: #4568dc;
            --accent: #ffd700;
            --text-main: #ffffff;
            --text-muted: #a0a0a0;
            --success: #00ff87;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans TC', sans-serif;
        }

        body {
            background: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            padding: 20px;
        }

        /* Background Particles (Pseudo-element for atmosphere) */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(76, 29, 149, 0.2) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
            animation: pulseBackground 10s infinite alternate;
        }

        @keyframes pulseBackground {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.2); opacity: 0.8; }
        }

        .container {
            width: 100%;
            max-width: 800px;
            position: relative;
            z-index: 1;
        }

        /* Glassmorphism Card */
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: var(--glass-shadow);
            padding: 40px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* Typography */
        h1, h2, h3 {
            font-family: 'Cinzel', serif;
            text-align: center;
            color: var(--text-main);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(to right, #fff, #b06ab3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            line-height: 1.8;
            color: #e0e0e0;
            font-size: 1.1rem;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(45deg, var(--secondary), var(--primary));
            border: none;
            border-radius: 50px;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-family: 'Cinzel', serif;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.2), transparent);
            transform: translateX(-100%);
            transition: 0.5s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(176, 106, 179, 0.4);
        }

        .btn:hover::after {
            transform: translateX(100%);
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary);
            box-shadow: none;
        }

        .btn-secondary:hover {
            background: rgba(176, 106, 179, 0.1);
        }

        /* Screens */
        .screen {
            display: none;
            animation: fadeIn 0.5s ease-out;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Welcome Screen */
        .welcome-content {
            text-align: center;
        }
        
        .welcome-desc {
            margin-bottom: 40px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .rune-decoration {
            font-size: 3rem;
            margin-bottom: 20px;
            color: var(--accent);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Quiz Screen */
        .progress-container {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            margin-bottom: 30px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px var(--primary);
        }

        .question-card h3 {
            font-size: 1.5rem;
            margin-bottom: 30px;
            text-align: left;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            gap: 15px;
        }

        .option-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: left;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .option-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .option-btn.selected {
            background: rgba(176, 106, 179, 0.2);
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(176, 106, 179, 0.2);
        }

        .option-btn::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 4px;
            background: var(--primary);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .option-btn:hover::before, .option-btn.selected::before {
            opacity: 1;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        /* Loading Screen */
        .loading-container {
            text-align: center;
            padding: 60px 0;
        }

        .magic-circle {
            width: 100px;
            height: 100px;
            border: 4px solid transparent;
            border-top-color: var(--accent);
            border-right-color: var(--primary);
            border-radius: 50%;
            margin: 0 auto 30px;
            animation: spin 1.5s linear infinite;
            position: relative;
        }

        .magic-circle::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 4px solid transparent;
            border-top-color: var(--secondary);
            border-left-color: var(--primary);
            border-radius: 50%;
            animation: spin 2s linear infinite reverse;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Result Screen */
        .result-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .class-title {
            font-size: 3.5rem;
            color: var(--accent);
            margin: 10px 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
            to { text-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 0 10px var(--primary); }
        }

        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        @media (max-width: 768px) {
            .result-grid {
                grid-template-columns: 1fr;
            }
        }

        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .result-details {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .trait-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .trait-tag {
            background: rgba(255,255,255,0.1);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--accent);
        }

        .secondary-class {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .secondary-class span {
            color: var(--primary);
            font-weight: bold;
            font-size: 1.1rem;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }

        /* SVG Radar Chart Styles */
        .radar-chart {
            width: 100%;
            max-width: 300px;
            overflow: visible;
        }
        .radar-grid {
            fill: none;
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        }
        .radar-axis {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        }
        .radar-area {
            fill: rgba(176, 106, 179, 0.4);
            stroke: var(--accent);
            stroke-width: 2;
            filter: drop-shadow(0 0 8px rgba(176, 106, 179, 0.5));
        }
        .radar-label {
            fill: var(--text-muted);
            font-size: 12px;
            text-anchor: middle;
            font-family: 'Cinzel', serif;
        }

    </style>
</head>
<body>

    <div class="container">
        
        <!-- Welcome Screen -->
        <div id="welcome-screen" class="screen active glass-card">
            <div class="welcome-content">
                <div class="rune-decoration">✦ ✧ ✦</div>
                <h1>靈魂共鳴</h1>
                <h2>命定遊戲職業鑑定</h2>
                <div style="margin: 30px 0; height: 2px; background: linear-gradient(90deg, transparent, var(--primary), transparent);"></div>
                <p class="welcome-desc">
                    在廣袤的數位宇宙中，每個靈魂都有其獨特的頻率。<br>
                    透過古老的心理演算法，我們將解析你的性格特質，<br>
                    為你匹配最契合的傳奇職業。
                </p>
                <button class="btn" onclick="startQuiz()">開始共鳴</button>
            </div>
        </div>

        <!-- Quiz Screen -->
        <div id="quiz-screen" class="screen glass-card">
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="question-card">
                <h3 id="question-text">Loading question...</h3>
                <div class="options-grid" id="options-container">
                    <!-- Options injected via JS -->
                </div>
            </div>

            <div class="nav-buttons">
                <button class="btn btn-secondary" id="prev-btn" onclick="prevQuestion()" disabled>返回</button>
                <button class="btn" id="next-btn" onclick="nextQuestion()" disabled>確認</button>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loading-screen" class="screen glass-card">
            <div class="loading-container">
                <div class="magic-circle"></div>
                <h3>正在解析靈魂迴路...</h3>
                <p id="loading-text">計算屬性加成...</p>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="screen glass-card">
            <div class="result-header">
                <p>靈魂共鳴完成。你的命定職業是：</p>
                <h2 class="class-title" id="result-title">職業名稱</h2>
                <div class="trait-tags" id="result-traits">
                    <!-- Traits injected via JS -->
                </div>
            </div>

            <div class="result-grid">
                <div class="chart-container">
                    <!-- SVG Radar Chart -->
                    <svg class="radar-chart" viewBox="0 0 300 300" id="radar-svg">
                        <!-- Chart generated via JS -->
                    </svg>
                </div>
                <div class="result-details">
                    <p id="result-desc">職業描述...</p>
                    
                    <div class="secondary-class" id="second-result">
                        <!-- Second class injected via JS -->
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="restartQuiz()">重新鑑定</button>
                <button class="btn" onclick="shareResult()">分享結果</button>
            </div>
        </div>

    </div>

    <script>
        // --- Data ---
        const allQuestions = [
            { id: 1, text: "當你面對無法獨自解決的困難時，你通常會？", options: [
                { text: "咬緊牙關，嘗試突破極限", points: { warrior: 3, berserker: 3, tank: 2, paladin: 1 } },
                { text: "冷靜分析弱點，尋找捷徑", points: { mage: 3, strategist: 3, scholar: 2, ranger: 1 } },
                { text: "尋找盟友，集結眾人力量", points: { healer: 3, bard: 2, summoner: 2, support: 3 } },
                { text: "暫時撤退，等待最佳時機", points: { rogue: 3, ninja: 2, hunter: 2, assassin: 3 } }
            ]},
            { id: 2, text: "在一個陌生的聚會中，你的位置通常是？", options: [
                { text: "舞台中央，帶動氣氛", points: { bard: 3, paladin: 1, berserker: 2, warrior: 1 } },
                { text: "角落觀察，洞悉全場", points: { mage: 2, scholar: 3, ranger: 2, rogue: 2 } },
                { text: "穿梭人群，照顧每個人", points: { healer: 3, support: 3, tank: 2, paladin: 2 } },
                { text: "若即若離，保持神祕", points: { assassin: 3, ninja: 3, hunter: 2, mage: 1 } }
            ]},
            { id: 3, text: "如果能獲得一種超能力，你希望是？", options: [
                { text: "金剛不壞的身體", points: { warrior: 3, berserker: 2, tank: 3 } },
                { text: "操控元素的智慧", points: { mage: 3, scholar: 3, summoner: 2 } },
                { text: "治癒萬物的雙手", points: { healer: 3, support: 3, paladin: 2 } },
                { text: "瞬間移動的敏捷", points: { rogue: 3, ninja: 3, assassin: 3 } }
            ]},
            { id: 4, text: "面對突發的危機狀況，你的第一反應？", options: [
                { text: "挺身而出，擋在最前", points: { warrior: 3, tank: 3, paladin: 2 } },
                { text: "快速思考，制定對策", points: { strategist: 3, mage: 2, scholar: 2 } },
                { text: "安撫恐慌，穩定人心", points: { healer: 3, bard: 2, support: 3 } },
                { text: "隱匿行蹤，伺機而動", points: { rogue: 3, assassin: 2, ninja: 3 } }
            ]},
            { id: 5, text: "你認為團隊中最不可或缺的是？", options: [
                { text: "強大的領導與執行力", points: { warrior: 2, paladin: 3, strategist: 2 } },
                { text: "淵博的知識與創意", points: { mage: 3, scholar: 2, summoner: 3 } },
                { text: "成員間的信任與和諧", points: { healer: 3, support: 3, bard: 2 } },
                { text: "各自為戰的專業能力", points: { assassin: 3, hunter: 3, rogue: 2 } }
            ]},
            { id: 6, text: "對於「規則」，你的看法是？", options: [
                { text: "規則是秩序的基石", points: { paladin: 3, tank: 2, warrior: 1 } },
                { text: "規則值得研究與優化", points: { mage: 2, scholar: 3, strategist: 2 } },
                { text: "規則應為人服務", points: { bard: 3, healer: 2, support: 1 } },
                { text: "規則是用來打破的", points: { rogue: 3, ninja: 3, berserker: 2 } }
            ]},
            { id: 7, text: "休閒時光，你偏好？", options: [
                { text: "揮灑汗水的運動", points: { warrior: 3, berserker: 2, ranger: 2 } },
                { text: "沉浸書海或解謎", points: { mage: 3, scholar: 3, strategist: 2 } },
                { text: "與親友聚會聊天", points: { bard: 3, healer: 2, support: 2 } },
                { text: "獨自一人的探險", points: { rogue: 2, hunter: 3, assassin: 2 } }
            ]},
            { id: 8, text: "你最重視的價值觀？", options: [
                { text: "榮譽與忠誠", points: { warrior: 2, paladin: 3, tank: 3 } },
                { text: "真理與智慧", points: { mage: 3, scholar: 3, summoner: 2 } },
                { text: "愛與和平", points: { healer: 3, support: 3, bard: 2 } },
                { text: "自由與獨立", points: { rogue: 3, hunter: 3, assassin: 2 } }
            ]}
        ];

        // Ensure we always have 8 questions. If we had more, we'd shuffle and slice.
        // For this version, I'll use the fixed set to ensure quality, or shuffle if needed.
        let questions = [];

        const classDescriptions = {
            warrior: { name: "戰士 (Warrior)", description: "前線的勇者，以無畏的勇氣直面挑戰。你擁有堅韌的意志，是團隊最堅實的依靠。", traits: ["勇敢", "堅韌", "行動派"], stats: [10, 4, 6, 9, 5, 6] },
            mage: { name: "大法師 (Archmage)", description: "真理的探求者，掌握著知識的力量。你善於分析與創新，能看透事物的本質。", traits: ["智慧", "洞察", "理性"], stats: [3, 10, 5, 4, 6, 7] },
            healer: { name: "聖職者 (Cleric)", description: "慈愛的守護者，為世界帶來治癒與希望。你擁有強大的同理心，是團隊的精神支柱。", traits: ["奉獻", "溫柔", "包容"], stats: [5, 8, 4, 6, 7, 9] },
            rogue: { name: "俠盜 (Rogue)", description: "陰影中的舞者，追求自由與打破常規。你機智靈活，總能在絕境中找到出路。", traits: ["機智", "自由", "靈活"], stats: [6, 6, 10, 5, 8, 5] },
            paladin: { name: "聖騎士 (Paladin)", description: "光明的守護者，誓死捍衛正義與信念。你兼具力量與德行，是天生的領導者。", traits: ["正義", "領導", "忠誠"], stats: [9, 6, 4, 8, 6, 8] },
            berserker: { name: "狂戰士 (Berserker)", description: "怒火的化身，以絕對的力量粉碎障礙。你的熱情如火，無人能擋。", traits: ["狂野", "激情", "力量"], stats: [10, 3, 7, 8, 4, 5] },
            ranger: { name: "遊俠 (Ranger)", description: "自然的守望者，適應力極強的生存大師。你觀察敏銳，在任何環境都能游刃有餘。", traits: ["敏銳", "獨立", "適應"], stats: [7, 6, 9, 6, 7, 5] },
            assassin: { name: "刺客 (Assassin)", description: "冷酷的終結者，專注於目標的達成。你行事果斷，不拖泥帶水。", traits: ["專注", "精準", "果斷"], stats: [6, 7, 10, 4, 6, 4] },
            bard: { name: "吟遊詩人 (Bard)", description: "傳奇的歌頌者，用魅力與故事連結人心。你是社交的天才，總能帶來歡笑與激勵。", traits: ["魅力", "創意", "社交"], stats: [4, 7, 6, 5, 8, 10] },
            scholar: { name: "學者 (Scholar)", description: "博學的智者，沈浸於無盡的知識海洋。你深思熟慮，總能提供獨到的見解。", traits: ["博學", "冷靜", "邏輯"], stats: [2, 10, 4, 3, 5, 6] },
            ninja: { name: "忍者 (Ninja)", description: "隱祕的執行者，行動如風，動靜皆宜。你善於忍耐與等待，不出手則已，一出手必中。", traits: ["神祕", "忍耐", "策略"], stats: [7, 7, 9, 6, 5, 4] },
            tank: { name: "守護者 (Guardian)", description: "堅不可摧的堡壘，為了守護他人而存在。你的犧牲精神令人動容。", traits: ["可靠", "犧牲", "穩重"], stats: [8, 5, 3, 10, 5, 6] },
            hunter: { name: "賞金獵人 (Hunter)", description: "目標的追蹤者，擁有超乎常人的耐心與專注。一旦被你鎖定，就無處可逃。", traits: ["耐心", "務實", "獨立"], stats: [7, 6, 8, 6, 7, 4] },
            summoner: { name: "召喚師 (Summoner)", description: "靈界的溝通者，擁有豐富的想像力與創造力。你善於整合資源，創造無限可能。", traits: ["想像", "協調", "靈性"], stats: [3, 9, 5, 4, 8, 7] },
            strategist: { name: "戰術家 (Strategist)", description: "戰場的棋手，運籌帷幄之中，決勝千里之外。你總能看清大局，制定最佳方案。", traits: ["遠見", "規劃", "智慧"], stats: [4, 9, 5, 5, 7, 8] },
            support: { name: "賢者 (Sage)", description: "幕後的推手，成就他人的偉大。你謙遜而強大，是團隊運作的核心潤滑劑。", traits: ["謙遜", "輔助", "智慧"], stats: [4, 8, 5, 6, 6, 8] }
        };

        // Stats Order for Radar Chart: STR, INT, AGI, VIT, LUCK, CHR
        const STAT_LABELS = ["力量", "智力", "敏捷", "體質", "幸運", "魅力"];

        // --- State Management ---
        let currentQuestionIndex = 0;
        let userAnswers = []; // Store indices of selected options
        let classScores = {};

        // --- Initialization ---
        function init() {
            // Shuffle questions or just pick 8 random ones if pool is larger
            questions = [...allQuestions].sort(() => 0.5 - Math.random()).slice(0, 8);
            userAnswers = new Array(questions.length).fill(null);
            resetScores();
        }

        function resetScores() {
            Object.keys(classDescriptions).forEach(key => classScores[key] = 0);
        }

        function startQuiz() {
            init();
            switchScreen('quiz-screen');
            showQuestion(0);
        }

        function switchScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            window.scrollTo(0, 0);
        }

        // --- Quiz Logic ---
        function showQuestion(index) {
            currentQuestionIndex = index;
            
            // Update Progress
            const progress = ((index) / questions.length) * 100;
            document.getElementById('progress-bar').style.width = `${progress}%`;

            // Update Text
            const q = questions[index];
            document.getElementById('question-text').innerText = `Q${index + 1}. ${q.text}`;

            // Render Options
            const container = document.getElementById('options-container');
            container.innerHTML = '';

            // Shuffle options for display, but map back to original index
            const optionsWithIndex = q.options.map((opt, i) => ({...opt, originalIndex: i}));
            // We can shuffle visually if we want, but simpler to keep order or shuffle once
            // Let's shuffle visually
            const shuffledOptions = optionsWithIndex.sort(() => 0.5 - Math.random());

            shuffledOptions.forEach((opt) => {
                const btn = document.createElement('div');
                btn.className = 'option-btn';
                if (userAnswers[index] === opt.originalIndex) {
                    btn.classList.add('selected');
                }
                btn.innerHTML = opt.text;
                btn.onclick = () => selectOption(opt.originalIndex, btn);
                container.appendChild(btn);
            });

            // Update Buttons
            document.getElementById('prev-btn').disabled = index === 0;
            document.getElementById('next-btn').disabled = userAnswers[index] === null;
            document.getElementById('next-btn').innerText = index === questions.length - 1 ? '完成鑑定' : '下一題';
        }

        function selectOption(originalIndex, btnElement) {
            userAnswers[currentQuestionIndex] = originalIndex;
            
            // UI Update
            const allBtns = document.getElementById('options-container').children;
            for (let btn of allBtns) {
                btn.classList.remove('selected');
            }
            btnElement.classList.add('selected');
            
            document.getElementById('next-btn').disabled = false;
            
            // Auto advance after short delay? Maybe not, let user confirm.
        }

        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                showQuestion(currentQuestionIndex - 1);
            }
        }

        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                showQuestion(currentQuestionIndex + 1);
            } else {
                finishQuiz();
            }
        }

        // --- Result Calculation ---
        function finishQuiz() {
            switchScreen('loading-screen');
            
            // Calculate Scores
            resetScores();
            questions.forEach((q, qIdx) => {
                const answerIdx = userAnswers[qIdx];
                const points = q.options[answerIdx].points;
                Object.entries(points).forEach(([cls, val]) => {
                    if (classScores[cls] !== undefined) {
                        classScores[cls] += val;
                    }
                });
            });

            // Simulate loading
            const loadingTexts = ["正在分析靈魂波長...", "構建屬性模型...", "匹配英雄位階...", "共鳴完成！"];
            let step = 0;
            const interval = setInterval(() => {
                if (step < loadingTexts.length) {
                    document.getElementById('loading-text').innerText = loadingTexts[step];
                    step++;
                } else {
                    clearInterval(interval);
                    showResults();
                }
            }, 800);
        }

        function showResults() {
            // Find winner
            let sortedClasses = Object.entries(classScores).sort((a, b) => b[1] - a[1]);
            const winnerKey = sortedClasses[0][0];
            const runnerUpKey = sortedClasses[1][0];
            
            const winnerData = classDescriptions[winnerKey];
            const runnerUpData = classDescriptions[runnerUpKey];

            // Render Result
            document.getElementById('result-title').innerText = winnerData.name;
            document.getElementById('result-desc').innerText = winnerData.description;
            
            const traitsContainer = document.getElementById('result-traits');
            traitsContainer.innerHTML = winnerData.traits.map(t => `<span class="trait-tag">${t}</span>`).join('');

            document.getElementById('second-result').innerHTML = `
                與你第二契合的職業是：<span>${runnerUpData.name}</span>
            `;

            // Draw Chart
            drawRadarChart(winnerData.stats);

            switchScreen('result-screen');
        }

        function drawRadarChart(stats) {
            const svg = document.getElementById('radar-svg');
            const centerX = 150;
            const centerY = 150;
            const radius = 100;
            const sides = 6;
            
            // Clear SVG
            svg.innerHTML = '';

            // Draw Grid (Concentric hexagons)
            for (let i = 1; i <= 5; i++) {
                const r = (radius / 5) * i;
                let points = [];
                for (let j = 0; j < sides; j++) {
                    const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;
                    const x = centerX + r * Math.cos(angle);
                    const y = centerY + r * Math.sin(angle);
                    points.push(`${x},${y}`);
                }
                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                poly.setAttribute("points", points.join(" "));
                poly.setAttribute("class", "radar-grid");
                svg.appendChild(poly);
            }

            // Draw Axis Lines & Labels
            for (let j = 0; j < sides; j++) {
                const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", centerX);
                line.setAttribute("y1", centerY);
                line.setAttribute("x2", x);
                line.setAttribute("y2", y);
                line.setAttribute("class", "radar-axis");
                svg.appendChild(line);

                // Labels
                const labelX = centerX + (radius + 20) * Math.cos(angle);
                const labelY = centerY + (radius + 20) * Math.sin(angle);
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", labelX);
                text.setAttribute("y", labelY + 5); // small adjustment
                text.setAttribute("class", "radar-label");
                text.textContent = STAT_LABELS[j];
                svg.appendChild(text);
            }

            // Draw Data Area
            // stats is array of 6 numbers (1-10)
            let dataPoints = [];
            for (let j = 0; j < sides; j++) {
                const val = stats[j];
                const r = (radius / 10) * val;
                const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                dataPoints.push(`${x},${y}`);
            }
            
            const area = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            area.setAttribute("points", dataPoints.join(" "));
            area.setAttribute("class", "radar-area");
            
            // Animate scale
            area.style.transformOrigin = "center";
            area.style.transform = "scale(0)";
            area.style.transition = "transform 1s cubic-bezier(0.4, 0, 0.2, 1)";
            
            svg.appendChild(area);

            // Trigger animation
            setTimeout(() => {
                area.style.transform = "scale(1)";
            }, 100);
        }

        function restartQuiz() {
            switchScreen('welcome-screen');
        }

        function shareResult() {
            const title = document.getElementById('result-title').innerText;
            const text = `我在靈魂共鳴測驗中測出的命定職業是：${title}！快來測試你的RPG職業吧！`;
            if (navigator.share) {
                navigator.share({
                    title: '靈魂共鳴：命定遊戲職業鑑定',
                    text: text,
                    url: window.location.href
                });
            } else {
                // Fallback
                navigator.clipboard.writeText(`${text} ${window.location.href}`);
                alert('結果已複製到剪貼簿！');
            }
        }

    </script>
</body>
</html>
